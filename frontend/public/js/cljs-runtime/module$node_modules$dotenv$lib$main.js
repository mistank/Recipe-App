shadow$provide.module$node_modules$dotenv$lib$main = function(global, require, module, exports) {
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _dotenvKey(options) {
    return options && options.DOTENV_KEY && 0 < options.DOTENV_KEY.length ? options.DOTENV_KEY : process.env.DOTENV_KEY && 0 < process.env.DOTENV_KEY.length ? process.env.DOTENV_KEY : "";
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && 0 < options.path.length) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          fs.existsSync(filepath) && (possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`);
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    return fs.existsSync(possibleVaultPath) ? possibleVaultPath : null;
  }
  function _resolveHome(envPath) {
    return "~" === envPath[0] ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  var process = require("module$node_modules$process$browser"), Buffer = require("module$node_modules$buffer$index").Buffer;
  const fs = require("shadow$empty"), path = require("module$node_modules$path_browserify$index"), os = require("module$node_modules$os_browserify$browser"), crypto = require("module$node_modules$crypto_browserify$index"), version = require("module$node_modules$dotenv$package_json").version, LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg, DotenvModule = {configDotenv:function(options) {
    var dotenvPath = path.resolve(process.cwd(), ".env"), encoding = "utf8";
    const debug = !(!options || !options.debug);
    options && options.encoding ? encoding = options.encoding : debug && _debug("No encoding is specified. UTF-8 is used by default");
    dotenvPath = [dotenvPath];
    if (options && options.path) {
      if (Array.isArray(options.path)) {
        dotenvPath = [];
        for (var filepath of options.path) {
          dotenvPath.push(_resolveHome(filepath));
        }
      } else {
        dotenvPath = [_resolveHome(options.path)];
      }
    }
    let lastError;
    filepath = {};
    for (const path of dotenvPath) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path, {encoding}));
        DotenvModule.populate(filepath, parsed, options);
      } catch (e) {
        debug && _debug(`Failed to load ${path} ${e.message}`), lastError = e;
      }
    }
    encoding = process.env;
    options && null != options.processEnv && (encoding = options.processEnv);
    DotenvModule.populate(encoding, filepath, options);
    return lastError ? {parsed:filepath, error:lastError} : {parsed:filepath};
  }, _configVault:function(options) {
    console.log(`[dotenv@${version}][INFO] ${"Loading env from encrypted .env.vault"}`);
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    options && null != options.processEnv && (processEnv = options.processEnv);
    DotenvModule.populate(processEnv, parsed, options);
    return {parsed};
  }, _parseVault:function(options) {
    var vaultPath = _vaultPath(options), result = DotenvModule.configDotenv({path:vaultPath});
    if (!result.parsed) {
      throw result = Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`), result.code = "MISSING_DATA", result;
    }
    options = _dotenvKey(options).split(",");
    vaultPath = options.length;
    let decrypted;
    for (let i = 0; i < vaultPath; i++) {
      try {
        const key = options[i].trim();
        let uri = void 0;
        try {
          uri = new URL(key);
        } catch (error) {
          if ("ERR_INVALID_URL" === error.code) {
            const err = Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment\x3ddevelopment");
            err.code = "INVALID_DOTENV_KEY";
            throw err;
          }
          throw error;
        }
        const key$jscomp$0 = uri.password;
        if (!key$jscomp$0) {
          const err = Error("INVALID_DOTENV_KEY: Missing key part");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        const environment = uri.searchParams.get("environment");
        if (!environment) {
          const err = Error("INVALID_DOTENV_KEY: Missing environment part");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`, ciphertext = result.parsed[environmentKey];
        if (!ciphertext) {
          const err = Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
          err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
          throw err;
        }
        decrypted = DotenvModule.decrypt(ciphertext, key$jscomp$0);
        break;
      } catch (error) {
        if (i + 1 >= vaultPath) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }, config:function(options) {
    if (0 === _dotenvKey(options).length) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    return vaultPath ? DotenvModule._configVault(options) : (console.log(`[dotenv@${version}][WARN] ${`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`}`), DotenvModule.configDotenv(options));
  }, decrypt:function(encrypted, keyStr) {
    keyStr = Buffer.from(keyStr.slice(-64), "hex");
    encrypted = Buffer.from(encrypted, "base64");
    const nonce = encrypted.subarray(0, 12), authTag = encrypted.subarray(-16);
    encrypted = encrypted.subarray(12, -16);
    try {
      var aesgcm = crypto.createDecipheriv("aes-256-gcm", keyStr, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(encrypted)}${aesgcm.final()}`;
    } catch (error) {
      aesgcm = "Invalid key length" === error.message;
      keyStr = "Unsupported state or unable to authenticate data" === error.message;
      if (error instanceof RangeError || aesgcm) {
        throw aesgcm = Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)"), aesgcm.code = "INVALID_DOTENV_KEY", aesgcm;
      }
      if (keyStr) {
        throw aesgcm = Error("DECRYPTION_FAILED: Please check your DOTENV_KEY"), aesgcm.code = "DECRYPTION_FAILED", aesgcm;
      }
      throw error;
    }
  }, parse:function(src) {
    const obj = {};
    src = src.toString();
    src = src.replace(/\r\n?/mg, "\n");
    for (var match; null != (match = LINE.exec(src));) {
      const key = match[1];
      match = match[2] || "";
      match = match.trim();
      const maybeQuote = match[0];
      match = match.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      '"' === maybeQuote && (match = match.replace(/\\n/g, "\n"), match = match.replace(/\\r/g, "\r"));
      obj[key] = match;
    }
    return obj;
  }, populate:function(processEnv, parsed, options = {}) {
    const debug = !(!options || !options.debug);
    options = !(!options || !options.override);
    if ("object" !== typeof parsed) {
      throw processEnv = Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate"), processEnv.code = "OBJECT_REQUIRED", processEnv;
    }
    for (const key of Object.keys(parsed)) {
      Object.prototype.hasOwnProperty.call(processEnv, key) ? (!0 === options && (processEnv[key] = parsed[key]), debug && (!0 === options ? _debug(`"${key}" is already defined and WAS overwritten`) : _debug(`"${key}" is already defined and was NOT overwritten`))) : processEnv[key] = parsed[key];
    }
  }};
  module.exports.configDotenv = DotenvModule.configDotenv;
  module.exports._configVault = DotenvModule._configVault;
  module.exports._parseVault = DotenvModule._parseVault;
  module.exports.config = DotenvModule.config;
  module.exports.decrypt = DotenvModule.decrypt;
  module.exports.parse = DotenvModule.parse;
  module.exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
};

//# sourceMappingURL=module$node_modules$dotenv$lib$main.js.map
