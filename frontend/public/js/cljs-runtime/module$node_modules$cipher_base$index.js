shadow$provide.module$node_modules$cipher_base$index = function(global, require, module, exports) {
  function CipherBase(hashMode) {
    Transform.call(this);
    (this.hashMode = "string" === typeof hashMode) ? this[hashMode] = this._finalOrDigest : this["final"] = this._finalOrDigest;
    this._final && (this.__final = this._final, this._final = null);
    this._encoding = this._decoder = null;
  }
  function toBuffer(data, encoding) {
    if (data instanceof Buffer) {
      return data;
    }
    if ("string" === typeof data) {
      return Buffer.from(data, encoding);
    }
    if (useArrayBuffer && ArrayBuffer.isView(data)) {
      if (0 === data.byteLength) {
        return Buffer.alloc(0);
      }
      encoding = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      if (encoding.byteLength === data.byteLength) {
        return encoding;
      }
    }
    if (useUint8Array && data instanceof Uint8Array || Buffer.isBuffer(data) && data.constructor && "function" === typeof data.constructor.isBuffer && data.constructor.isBuffer(data)) {
      return Buffer.from(data);
    }
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  var Buffer = require("module$node_modules$safe_buffer$index").Buffer, Transform = require("module$node_modules$stream_browserify$index").Transform, StringDecoder = require("module$node_modules$string_decoder$lib$string_decoder").StringDecoder;
  require("module$node_modules$inherits$inherits_browser")(CipherBase, Transform);
  var useUint8Array = "undefined" !== typeof Uint8Array, useArrayBuffer = "undefined" !== typeof ArrayBuffer && "undefined" !== typeof Uint8Array && ArrayBuffer.isView && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);
  CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    data = toBuffer(data, inputEnc);
    data = this._update(data);
    if (this.hashMode) {
      return this;
    }
    outputEnc && (data = this._toString(data, outputEnc));
    return data;
  };
  CipherBase.prototype.setAutoPadding = function() {
  };
  CipherBase.prototype.getAuthTag = function() {
    throw Error("trying to get auth tag in unsupported state");
  };
  CipherBase.prototype.setAuthTag = function() {
    throw Error("trying to set auth tag in unsupported state");
  };
  CipherBase.prototype.setAAD = function() {
    throw Error("trying to set aad in unsupported state");
  };
  CipherBase.prototype._transform = function(data, _, next) {
    try {
      this.hashMode ? this._update(data) : this.push(this._update(data));
    } catch (e) {
      var err = e;
    } finally {
      next(err);
    }
  };
  CipherBase.prototype._flush = function(done) {
    try {
      this.push(this.__final());
    } catch (e) {
      var err = e;
    }
    done(err);
  };
  CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    outputEnc && (outData = this._toString(outData, outputEnc, !0));
    return outData;
  };
  CipherBase.prototype._toString = function(value, enc, fin) {
    this._decoder || (this._decoder = new StringDecoder(enc), this._encoding = enc);
    if (this._encoding !== enc) {
      throw Error("canâ€™t switch encodings");
    }
    value = this._decoder.write(value);
    fin && (value += this._decoder.end());
    return value;
  };
  module.exports = CipherBase;
};

//# sourceMappingURL=module$node_modules$cipher_base$index.js.map
