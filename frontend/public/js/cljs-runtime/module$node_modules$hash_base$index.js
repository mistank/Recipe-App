shadow$provide.module$node_modules$hash_base$index = function(global, require, module, exports) {
  function HashBase(blockSize) {
    Transform.call(this);
    this._block = Buffer.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = !1;
  }
  function toBuffer(data, encoding) {
    if (data instanceof Buffer) {
      return data;
    }
    if ("string" === typeof data) {
      return Buffer.from(data, encoding);
    }
    if (useArrayBuffer && ArrayBuffer.isView(data)) {
      if (0 === data.byteLength) {
        return Buffer.alloc(0);
      }
      encoding = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      if (encoding.byteLength === data.byteLength) {
        return encoding;
      }
    }
    if (useUint8Array && data instanceof Uint8Array || Buffer.isBuffer(data) && data.constructor && "function" === typeof data.constructor.isBuffer && data.constructor.isBuffer(data)) {
      return Buffer.from(data);
    }
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  var Buffer = require("module$node_modules$safe_buffer$index").Buffer, Transform = require("module$node_modules$stream_browserify$index").Transform;
  require("module$node_modules$inherits$inherits_browser")(HashBase, Transform);
  HashBase.prototype._transform = function(chunk, encoding, callback) {
    var error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  HashBase.prototype._flush = function(callback) {
    var error = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  var useUint8Array = "undefined" !== typeof Uint8Array, useArrayBuffer = "undefined" !== typeof ArrayBuffer && "undefined" !== typeof Uint8Array && ArrayBuffer.isView && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);
  HashBase.prototype.update = function(data, encoding) {
    if (this._finalized) {
      throw Error("Digest already called");
    }
    data = toBuffer(data, encoding);
    encoding = this._block;
    for (var offset = 0; this._blockOffset + data.length - offset >= this._blockSize;) {
      for (var i = this._blockOffset; i < this._blockSize;) {
        encoding[i++] = data[offset++];
      }
      this._update();
      this._blockOffset = 0;
    }
    for (; offset < data.length;) {
      encoding[this._blockOffset++] = data[offset++];
    }
    encoding = 0;
    for (data = 8 * data.length; 0 < data; ++encoding) {
      this._length[encoding] += data, data = this._length[encoding] / 4294967296 | 0, 0 < data && (this._length[encoding] -= 4294967296 * data);
    }
    return this;
  };
  HashBase.prototype._update = function() {
    throw Error("_update is not implemented");
  };
  HashBase.prototype.digest = function(encoding) {
    if (this._finalized) {
      throw Error("Digest already called");
    }
    this._finalized = !0;
    var digest = this._digest();
    void 0 !== encoding && (digest = digest.toString(encoding));
    this._block.fill(0);
    for (encoding = this._blockOffset = 0; 4 > encoding; ++encoding) {
      this._length[encoding] = 0;
    }
    return digest;
  };
  HashBase.prototype._digest = function() {
    throw Error("_digest is not implemented");
  };
  module.exports = HashBase;
};

//# sourceMappingURL=module$node_modules$hash_base$index.js.map
